#parses and validates the execution plan generated by the AI

import re
import os

def validate_command(command):

    #validate if a command is safe to execute        
    # returns True if the command is considered safe, otherwise False

    #list of dangerous commands/patterns to block
    dangerous_patterns = [
        # System-level dangerous operations (for Linux)
        r"rm\s+-rf\s+[/~]",        # Remove root or home dir
        r"mkfs",                    # Format filesystem
        r"dd\s+if=.+\s+of=/dev",    # Direct writing to devices
        r":(){ :\|:& };:",          # Fork bomb
        
        # Network danger
        r"wget.+\|\s*bash",          # Download and pipe to bash
        r"curl.+\|\s*bash",          # Download and pipe to bash
        r"Invoke-WebRequest.+\|\s*Invoke-Expression",  # PowerShell equivalent
        
        # Privilege escalation
        r"sudo\s+rm\s+-rf",         # Sudo remove with force recursion
        r"sudo\s+mkfs",             # Sudo format filesystem
        r"runas\s+/user:administrator",  # Windows run as admin
        
        # Windows-specific dangers
        r"format\s+[a-zA-Z]:",      # Format drive
        r"del\s+/[fFqQsS]\s+[a-zA-Z]:",    # Delete with force/quiet
        r"rmdir\s+/[sS]\s+[a-zA-Z]:",      # Remove directory with subdirs
        r"rd\s+/[sS]\s+[a-zA-Z]:",         # Remove directory (rd) variant
        r"reg\s+delete",                   # Registry deletion
        r"schtasks\s+/create",             # Create scheduled task
        r"wmic\s+process\s+call\s+create", # Create process with WMI
        r"net\s+user\s+\w+\s+\w+\s+/add",  # Add user account
        r"net\s+localgroup\s+administrators", # Modify admin group
        
        # General danger signs
        r">\s*/etc/",               # Write to /etc
        r">\s*/dev/",               # Write to /dev
        r">\s*/bin/",               # Write to /bin
        r">\s*/sbin/",              # Write to /sbin
        r">\s*[a-zA-Z]:\\Windows",  # Write to Windows directory
        r">\s*[a-zA-Z]:\\Program Files", # Write to Program Files
        r"Start-Process\s+-Verb\s+RunAs", # PowerShell elevation
    ]
    
    for pattern in dangerous_patterns:
        if re.search(pattern, command, re.IGNORECASE):
            return False
    
    return True

def extract_file_operations(plan):

    #extracts file writing operations from the plan
    
    #Returns a tuple: (refined_plan, file_operations)

    refined_plan = [] #List of commands with file operations removed
    file_operations = {} #Dict of {filename: content} pairs
    
    file_pattern = r'\[WRITE_FILE:([^\]]+)\](.*?)\[/WRITE_FILE\]'
    
    for step in plan:
        #Looking for file operations within each step
        matches = re.findall(file_pattern, step, re.DOTALL)
        
        if matches:
            for filename, content in matches:
                #clean the filename
                clean_filename = filename.strip().replace('\\', os.sep).replace('/', os.sep)
                
                #handle absolute vs relative paths more carefully
                if os.path.isabs(clean_filename):
                    #For security, only accept relative paths or paths in current directory
                    safe_filename = os.path.basename(clean_filename)
                else:
                    norm_path = os.path.normpath(clean_filename)
                    if norm_path.startswith('..'):
                        safe_filename = os.path.basename(norm_path)
                    else:
                        safe_filename = norm_path
                    
                file_operations[safe_filename] = content
                
            #replace the file operation with a standard command
            step = re.sub(file_pattern, '', step).strip()
            #only add non-empty steps
            if step:
                refined_plan.append(step)
        else:
            # IMP: checking if the step is a list or array (from bad AI formatting)
            if step.startswith('[') and (step.endswith(']') or ']' in step):
                try:
                    #try to parse as JSON array
                    import json
                    parsed_steps = json.loads(step.replace("'", '"'))
                    if isinstance(parsed_steps, list):
                        for substep in parsed_steps:
                            if substep and isinstance(substep, str):
                                refined_plan.append(substep)
                    else:
                        refined_plan.append(step)
                except:
                    #if parsing fails, add the step as-is
                    refined_plan.append(step)
            else:
                refined_plan.append(step)
    
    return refined_plan, file_operations

def parse_plan(plan):

    # main fn. to parse and validate the execution plan

    if not plan or not isinstance(plan, list):
        return [], {}, []
    
    #extract file operations
    refined_plan, file_operations = extract_file_operations(plan)
    
    #validate commands
    safe_commands = []
    unsafe_commands = []
    
    for command in refined_plan:
        if validate_command(command):
            safe_commands.append(command)
        else:
            unsafe_commands.append(command)
    
    return safe_commands, file_operations, unsafe_commands